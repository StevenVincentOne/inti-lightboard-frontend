"use client";

import { useEffect, useRef, useState, useCallback } from 'react';

interface User {
  id: string | number;
  username: string | null;
  displayName: string | null;
  email: string | null;
}

interface AuthState {
  loading: boolean;
  authenticated: boolean;
  user: User | null;
}

const WEBSOCKET_URL_BASE = "wss://6d3f40b3-1e49-4b09-85e4-36ff422ee88b-00-psvr1owg24vj.janeway.replit.dev/api/inti-ws";

// This hook now manages both communication AND authentication state
export const useIntiCommunication = () => {
  const ws = useRef<WebSocket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  
  // Create a comprehensive auth state managed by this hook
  const [authState, setAuthState] = useState<AuthState>({
    loading: true, // Start in a loading state
    authenticated: false,
    user: null,
  });

  // Fixed session/auth extraction to match main PWA storage keys
  const getSessionId = useCallback(() => {
    // 1. Check URL parameters first (for fresh redirects from Replit)
    const urlParams = new URLSearchParams(window.location.search);
    const urlSessionId = urlParams.get('session');
    if (urlSessionId) {
      console.log('[IntiComm] Found session in URL parameter:', urlSessionId.substring(0, 8) + '...');
      return urlSessionId;
    }
    
    // 2. Check stored auth data (MATCHING MAIN PWA STORAGE)
    const storedAuth = localStorage.getItem('inti_auth') || sessionStorage.getItem('inti_auth');
    if (storedAuth) {
      try {
        const parsed = JSON.parse(storedAuth);
        if (parsed.authenticated && parsed.user) {
          console.log('[IntiComm] Found stored auth data, using authenticated session');
          // Return a flag indicating we have stored auth (not a session ID)
          return 'STORED_AUTH';
        }
      } catch {
        console.log('[IntiComm] Invalid stored auth data, clearing...');
        localStorage.removeItem('inti_auth');
        sessionStorage.removeItem('inti_auth');
      }
    }
    
    // 3. Legacy session storage check (fallback)
    const legacySessionId = localStorage.getItem('intellipedia_session') || 
                           sessionStorage.getItem('sessionId') ||
                           document.cookie.split(';').find(c => c.trim().startsWith('sessionId='))?.split('=')[1];
    
    if (legacySessionId) {
      console.log('[IntiComm] Found legacy session:', legacySessionId.substring(0, 8) + '...');
      return legacySessionId;
    }
    
    console.log('[IntiComm] No session ID or auth data found in any source');
    return null;
  }, []);

  // Check for stored auth and set initial state
  const checkStoredAuth = useCallback(() => {
    const storedAuth = localStorage.getItem('inti_auth') || sessionStorage.getItem('inti_auth');
    if (storedAuth) {
      try {
        const parsed = JSON.parse(storedAuth);
        if (parsed.authenticated && parsed.user && parsed.user.displayName && parsed.user.displayName !== 'Replit User') {
          console.log('[IntiComm] Found valid stored authentication:', parsed.user.displayName);
          setAuthState({
            loading: false,
            authenticated: true,
            user: parsed.user
          });
          return true;
        }
      } catch {
        localStorage.removeItem('inti_auth');
        sessionStorage.removeItem('inti_auth');
      }
    }
    return false;
  }, []);

  const sendMessage = useCallback((type: string, data?: unknown) => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      const message = JSON.stringify({ type, data });
      console.log('[IntiComm] Sending message:', message);
      ws.current.send(message);
    } else {
      console.error('[IntiComm] Cannot send message, WebSocket is not open.');
    }
  }, []);

  const connect = useCallback(() => {
    if (ws.current && ws.current.readyState === WebSocket.OPEN) {
      console.log('[IntiComm] WebSocket already open.');
      return;
    }

    // Get session ID or check for stored auth
    const sessionInfo = getSessionId();
    let websocketUrl = WEBSOCKET_URL_BASE;

    if (sessionInfo && sessionInfo !== 'STORED_AUTH') {
      console.log(`[IntiComm] Authenticating WebSocket with sessionId: ${sessionInfo.substring(0, 8)}...`);
      websocketUrl = `${WEBSOCKET_URL_BASE}?clientType=PWA&sessionId=${sessionInfo}`;
    } else if (sessionInfo === 'STORED_AUTH') {
      console.log('[IntiComm] Using stored auth, connecting WebSocket without session parameter');
      websocketUrl = `${WEBSOCKET_URL_BASE}?clientType=PWA`;
    } else {
      console.log('[IntiComm] No session ID found. Connecting WebSocket without authentication.');
      websocketUrl = `${WEBSOCKET_URL_BASE}?clientType=PWA`;
    }

    console.log(`[IntiComm] Initializing WebSocket connection to: ${websocketUrl.replace(/sessionId=[^&]+/, 'sessionId=[REDACTED]')}`);
    ws.current = new WebSocket(websocketUrl);

    ws.current.onopen = () => {
      console.log('[IntiComm] WebSocket connection established.');
      setIsConnected(true);
    };

    ws.current.onmessage = (event) => {
      const message = JSON.parse(event.data);
      console.log('[IntiComm] Received message:', message);

      if (message.type === 'connection.established') {
        console.log('[IntiComm] Authentication status received from server:', message.data);
        
        // Update auth state based on server response
        setAuthState({
          loading: false,
          authenticated: message.data.authenticated || false,
          user: message.data.user || null,
        });
        
        // Store auth data if authenticated and not already stored
        if (message.data.authenticated && message.data.user && !localStorage.getItem('inti_auth')) {
          const authData = { user: message.data.user, authenticated: true };
          localStorage.setItem('inti_auth', JSON.stringify(authData));
          sessionStorage.setItem('inti_auth', JSON.stringify(authData));
        }
      }
    };

    ws.current.onclose = () => {
      console.log('[IntiComm] WebSocket connection closed.');
      setIsConnected(false);
      setAuthState({ loading: false, authenticated: false, user: null });
    };

    ws.current.onerror = (error) => {
      console.error('[IntiComm] WebSocket error:', error);
      setIsConnected(false);
      setAuthState({ loading: false, authenticated: false, user: null });
    };
  }, [getSessionId]);

  useEffect(() => {
    // First check for stored auth
    if (!checkStoredAuth()) {
      // If no stored auth, connect to WebSocket
      connect();
    }
    
    return () => {
      ws.current?.close();
    };
  }, [connect, checkStoredAuth]);

  return {
    isConnected,
    authState,
    sendMessage,
  };
};